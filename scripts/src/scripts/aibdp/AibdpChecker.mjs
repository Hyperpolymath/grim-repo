// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as GrimCore from "../../core/GrimCore.mjs";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Js_promise from "rescript/lib/es6/js_promise.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

var scriptInfo_matches = ["*://*/*"];

var scriptInfo = {
  name: "grim-aibdp-checker",
  version: "1.0.0",
  description: "Check and display AIBDP status for websites",
  matches: scriptInfo_matches
};

var aibdpPath = "/.well-known/aibdp.json";

function parseStatus(str) {
  var match = str.toLowerCase();
  switch (match) {
    case "allowed" :
        return "Allowed";
    case "conditional" :
        return "Conditional";
    case "refused" :
        return "Refused";
    default:
      return "Unknown";
  }
}

function parsePolicy(json) {
  var obj = Belt_Option.getWithDefault(Js_json.decodeObject(json), {});
  var status = Belt_Option.getWithDefault(Belt_Option.map(Belt_Option.flatMap(Js_dict.get(obj, "status"), Js_json.decodeString), parseStatus), "Unknown");
  var conditions = Belt_Option.getWithDefault(Belt_Option.map(Belt_Option.flatMap(Js_dict.get(obj, "conditions"), Js_json.decodeArray), (function (arr) {
              return Belt_Array.keepMap(arr, Js_json.decodeString);
            })), []);
  return {
          status: status,
          conditions: conditions
        };
}

function parseManifest(json) {
  var obj = Js_json.decodeObject(json);
  if (obj === undefined) {
    return ;
  }
  var version = Belt_Option.getWithDefault(Belt_Option.flatMap(Js_dict.get(obj, "aibdp_version"), Js_json.decodeString), "unknown");
  var contact = Belt_Option.flatMap(Js_dict.get(obj, "contact"), Js_json.decodeString);
  var expires = Belt_Option.flatMap(Js_dict.get(obj, "expires"), Js_json.decodeString);
  var policies = Belt_Option.getWithDefault(Belt_Option.flatMap(Js_dict.get(obj, "policies"), Js_json.decodeObject), {});
  var getPolicy = function (name) {
    return Belt_Option.getWithDefault(Belt_Option.map(Js_dict.get(policies, name), parsePolicy), {
                status: "Unknown",
                conditions: []
              });
  };
  return {
          version: version,
          contact: contact,
          expires: expires,
          training: getPolicy("training"),
          indexing: getPolicy("indexing"),
          summarization: getPolicy("summarization"),
          generativeReuse: getPolicy("generative_reuse"),
          embedding: getPolicy("embedding")
        };
}

function fetchAibdp() {
  var url = Belt_Array.slice(location.href.split("/"), 0, 3).join("/") + aibdpPath;
  GrimCore.Log.debug("Fetching AIBDP from: " + url);
  var __x = (function (__x) {
        return Js_promise.then_((function (resp) {
                      var httpStatus = resp.status;
                      if (httpStatus !== 200) {
                        if (httpStatus === 404) {
                          return Promise.resolve("NotFound");
                        } else {
                          return Promise.resolve({
                                      TAG: "Error",
                                      _0: "HTTP " + resp.status.toString()
                                    });
                        }
                      }
                      try {
                        var json = JSON.parse(resp.responseText);
                        var manifest = parseManifest(json);
                        if (manifest !== undefined) {
                          return Promise.resolve({
                                      TAG: "Found",
                                      _0: manifest
                                    });
                        } else {
                          return Promise.resolve({
                                      TAG: "Error",
                                      _0: "Invalid AIBDP format"
                                    });
                        }
                      }
                      catch (exn){
                        return Promise.resolve({
                                    TAG: "Error",
                                    _0: "Failed to parse AIBDP JSON"
                                  });
                      }
                    }), __x);
      })(GrimCore.HTTP.$$fetch(undefined, undefined, url));
  return Js_promise.$$catch((function (param) {
                return Promise.resolve({
                            TAG: "Error",
                            _0: "Network error"
                          });
              }), __x);
}

function statusToEmoji(status) {
  switch (status) {
    case "Allowed" :
        return "‚úì";
    case "Refused" :
        return "üîí";
    case "Conditional" :
        return "‚ö†Ô∏è";
    case "Unknown" :
        return "‚ùì";
    
  }
}

function statusToVariant(status) {
  switch (status) {
    case "Allowed" :
        return "success";
    case "Refused" :
        return "error";
    case "Conditional" :
        return "warning";
    case "Unknown" :
        return "info";
    
  }
}

function statusToText(status) {
  switch (status) {
    case "Allowed" :
        return "Allowed";
    case "Refused" :
        return "Refused";
    case "Conditional" :
        return "Conditional";
    case "Unknown" :
        return "Unknown";
    
  }
}

var badgeCSS = "\n  .grim-aibdp-badge {\n    position: fixed;\n    bottom: 20px;\n    left: 20px;\n    z-index: 99998;\n    cursor: pointer;\n    transition: transform 0.2s;\n  }\n  .grim-aibdp-badge:hover {\n    transform: scale(1.1);\n  }\n  .grim-aibdp-detail {\n    position: fixed;\n    bottom: 60px;\n    left: 20px;\n    z-index: 99999;\n    background: white;\n    border: 1px solid #dfe6e9;\n    border-radius: 8px;\n    padding: 16px;\n    min-width: 280px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n    font-family: -apple-system, BlinkMacSystemFont, sans-serif;\n    font-size: 13px;\n    display: none;\n  }\n  .grim-aibdp-detail.visible {\n    display: block;\n  }\n  .grim-aibdp-detail h4 {\n    margin: 0 0 12px 0;\n    font-size: 14px;\n    color: #2d3436;\n  }\n  .grim-aibdp-policy-row {\n    display: flex;\n    justify-content: space-between;\n    padding: 6px 0;\n    border-bottom: 1px solid #f1f3f4;\n  }\n  .grim-aibdp-policy-row:last-child {\n    border-bottom: none;\n  }\n  .grim-aibdp-policy-name {\n    font-weight: 500;\n    color: #636e72;\n  }\n  .grim-aibdp-policy-status {\n    font-weight: 600;\n  }\n  .grim-aibdp-status-allowed { color: #27ae60; }\n  .grim-aibdp-status-refused { color: #e74c3c; }\n  .grim-aibdp-status-conditional { color: #f39c12; }\n  .grim-aibdp-status-unknown { color: #95a5a6; }\n  .grim-aibdp-meta {\n    margin-top: 12px;\n    padding-top: 12px;\n    border-top: 1px solid #dfe6e9;\n    font-size: 11px;\n    color: #95a5a6;\n  }\n";

function renderPolicyRow(name, policy) {
  var match = policy.status;
  var statusClass;
  switch (match) {
    case "Allowed" :
        statusClass = "allowed";
        break;
    case "Refused" :
        statusClass = "refused";
        break;
    case "Conditional" :
        statusClass = "conditional";
        break;
    case "Unknown" :
        statusClass = "unknown";
        break;
    
  }
  return "<div class=\"grim-aibdp-policy-row\">\n    <span class=\"grim-aibdp-policy-name\">" + name + "</span>\n    <span class=\"grim-aibdp-policy-status grim-aibdp-status-" + statusClass + "\">\n      " + statusToEmoji(policy.status) + " " + statusToText(policy.status) + "\n    </span>\n  </div>";
}

function createBadge(result) {
  GM_addStyle(badgeCSS);
  var match;
  if (typeof result !== "object") {
    match = [
      "‚ùì No AIBDP",
      "info"
    ];
  } else if (result.TAG === "Found") {
    var manifest = result._0;
    match = [
      statusToEmoji(manifest.training.status) + " AIBDP",
      statusToVariant(manifest.training.status)
    ];
  } else {
    match = [
      "‚ö†Ô∏è AIBDP Error",
      "warning"
    ];
  }
  var badgeContainer = GrimCore.DOM.create("div", "grim-aibdp-badge", undefined);
  var badge = GrimCore.UI.createBadge(match[0], match[1]);
  badgeContainer.appendChild(badge);
  var detailPanel = GrimCore.DOM.create("div", "grim-aibdp-detail", undefined);
  var detailContent;
  if (typeof result !== "object") {
    detailContent = "<h4>‚ùì No AIBDP Found</h4>\n       <p>This site has not published an AI Boundary Declaration Protocol manifest.</p>\n       <p style=\"font-size: 11px; color: #95a5a6;\">\n         Learn more at <a href=\"https://aibdp.org\" target=\"_blank\">aibdp.org</a>\n       </p>";
  } else if (result.TAG === "Found") {
    var manifest$1 = result._0;
    var policies = [
      [
        "AI Training",
        manifest$1.training
      ],
      [
        "Indexing",
        manifest$1.indexing
      ],
      [
        "Summarization",
        manifest$1.summarization
      ],
      [
        "Generative Reuse",
        manifest$1.generativeReuse
      ],
      [
        "Embedding",
        manifest$1.embedding
      ]
    ];
    var policyRows = Belt_Array.map(policies, (function (param) {
              return renderPolicyRow(param[0], param[1]);
            })).join("");
    var contact = manifest$1.contact;
    var metaInfo = contact !== undefined ? "<div class=\"grim-aibdp-meta\">Contact: " + contact + "</div>" : "";
    detailContent = "<h4>üîê AIBDP v" + manifest$1.version + "</h4>\n       " + policyRows + "\n       " + metaInfo;
  } else {
    detailContent = "<h4>‚ö†Ô∏è AIBDP Error</h4>\n       <p>Could not fetch AIBDP manifest: " + result._0 + "</p>";
  }
  detailPanel.innerHTML = detailContent;
  badgeContainer.addEventListener("click", (function (param) {
          detailPanel["classList.toggle"]("visible");
        }));
  document.body.addEventListener("click", (function ($$event) {
          (event.target);
          if (!(badgeContainer.contains(target)) && !(detailPanel.contains(target))) {
            detailPanel["classList.remove"]("visible");
            return ;
          }
          
        }));
  document.body.appendChild(badgeContainer);
  document.body.appendChild(detailPanel);
}

var cacheKey = "aibdp_cache";

function getCached() {
  var __x = GrimCore.$$Storage.getJson("Local", cacheKey);
  return Js_promise.then_((function (cached) {
                if (cached === undefined) {
                  return Promise.resolve(undefined);
                }
                var obj = Belt_Option.getWithDefault(Js_json.decodeObject(cached), {});
                var host = Belt_Option.flatMap(Js_dict.get(obj, "host"), Js_json.decodeString);
                var timestamp = Belt_Option.flatMap(Js_dict.get(obj, "timestamp"), Js_json.decodeNumber);
                if (host === undefined) {
                  return Promise.resolve(undefined);
                }
                if (timestamp === undefined) {
                  return Promise.resolve(undefined);
                }
                if (!(host === location.host && Date.now() - timestamp < 3600000.0)) {
                  return Promise.resolve(undefined);
                }
                var resultStr = Belt_Option.flatMap(Js_dict.get(obj, "result"), Js_json.decodeString);
                if (resultStr === undefined) {
                  return Promise.resolve(undefined);
                }
                if (resultStr === "not_found") {
                  return Promise.resolve("NotFound");
                }
                try {
                  var parsed = JSON.parse(resultStr);
                  var m = parseManifest(parsed);
                  if (m !== undefined) {
                    return Promise.resolve({
                                TAG: "Found",
                                _0: m
                              });
                  } else {
                    return Promise.resolve(undefined);
                  }
                }
                catch (exn){
                  return Promise.resolve(undefined);
                }
              }), __x);
}

function setCache(result) {
  var resultStr;
  resultStr = typeof result !== "object" ? "not_found" : (
      result.TAG === "Found" ? "found" : "error"
    );
  var cache = {};
  cache["host"] = location.host;
  cache["result"] = resultStr;
  cache["timestamp"] = Date.now();
  return GrimCore.$$Storage.setJson("Local", cacheKey, cache);
}

function run() {
  GrimCore.Log.info("AIBDP Checker running");
  ((function (__x) {
          return Js_promise.then_((function (cached) {
                        if (cached !== undefined) {
                          GrimCore.Log.debug("Using cached AIBDP result");
                          createBadge(cached);
                          return Promise.resolve();
                        } else {
                          var __x = fetchAibdp();
                          return Js_promise.then_((function (result) {
                                        createBadge(result);
                                        setCache(result);
                                        return Promise.resolve();
                                      }), __x);
                        }
                      }), __x);
        })(getCached()));
}

GrimCore.Registry.register("grim-aibdp-checker", scriptInfo);

document.body.addEventListener("load", (function (param) {
        run();
      }));

if ((document.readyState === "complete")) {
  run();
}

export {
  scriptInfo ,
  aibdpPath ,
  parseStatus ,
  parsePolicy ,
  parseManifest ,
  fetchAibdp ,
  statusToEmoji ,
  statusToVariant ,
  statusToText ,
  badgeCSS ,
  renderPolicyRow ,
  createBadge ,
  cacheKey ,
  getCached ,
  setCache ,
  run ,
}
/*  Not a pure module */
