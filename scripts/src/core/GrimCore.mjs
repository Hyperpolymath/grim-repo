// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_promise from "rescript/lib/es6/js_promise.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

var GM = {};

var $$default = {
  version: "1.0.0",
  debug: false,
  prefix: "grim"
};

var current = {
  contents: $$default
};

function setDebug(enabled) {
  var init = current.contents;
  current.contents = {
    version: init.version,
    debug: enabled,
    prefix: init.prefix
  };
}

function isDebug() {
  return current.contents.debug;
}

var Config = {
  $$default: $$default,
  current: current,
  setDebug: setDebug,
  isDebug: isDebug
};

var prefix = "[Grim]";

function info(msg) {
  console.log(prefix, msg);
}

function warn(msg) {
  console.warn(prefix, msg);
}

function error(msg) {
  console.error(prefix, msg);
}

function debug(msg) {
  if (current.contents.debug) {
    console.log(prefix, "[DEBUG]", msg);
    return ;
  }
  
}

var Log = {
  prefix: prefix,
  info: info,
  warn: warn,
  error: error,
  debug: debug
};

function query(selector) {
  return Caml_option.nullable_to_opt(document.querySelector(selector));
}

function queryAll(selector) {
  document.querySelectorAll(selector);
  return (Array.from(nodeList));
}

function create(tag, classNameOpt, idOpt) {
  var className = classNameOpt !== undefined ? classNameOpt : "";
  var id = idOpt !== undefined ? idOpt : "";
  var el = document.createElement(tag);
  if (className !== "") {
    el["classList.add"](className);
  }
  if (id !== "") {
    el.setAttribute("id", id);
  }
  return el;
}

function waitFor(selector, timeoutOpt) {
  var timeout = timeoutOpt !== undefined ? timeoutOpt : 5000;
  return new Promise((function (resolve, param) {
                var startTime = Date.now();
                var check = function () {
                  var el = Caml_option.nullable_to_opt(document.querySelector(selector));
                  if (el !== undefined) {
                    return resolve(Caml_option.some(Caml_option.valFromOption(el)));
                  } else if (Date.now() - startTime > timeout) {
                    return resolve(undefined);
                  } else {
                    setTimeout(check, 100);
                    return ;
                  }
                };
                check();
              }));
}

var DOM = {
  query: query,
  queryAll: queryAll,
  create: create,
  waitFor: waitFor
};

var storagePrefix = "grim_";

function prefixKey(key) {
  return storagePrefix + key;
}

function get(storageOpt, key) {
  var storage = storageOpt !== undefined ? storageOpt : "Local";
  var prefixedKey = storagePrefix + key;
  switch (storage) {
    case "Local" :
        return Promise.resolve(Caml_option.nullable_to_opt(localStorage.getItem(prefixedKey)));
    case "Session" :
        return Promise.resolve(Caml_option.nullable_to_opt(sessionStorage.getItem(prefixedKey)));
    case "GM" :
        var __x = GM_getValue(prefixedKey, "");
        return Js_promise.then_((function (value) {
                      return Promise.resolve(value === "" ? undefined : value);
                    }), __x);
    
  }
}

function set(storageOpt, key, value) {
  var storage = storageOpt !== undefined ? storageOpt : "Local";
  var prefixedKey = storagePrefix + key;
  switch (storage) {
    case "Local" :
        localStorage.setItem(prefixedKey, value);
        return Promise.resolve();
    case "Session" :
        sessionStorage.setItem(prefixedKey, value);
        return Promise.resolve();
    case "GM" :
        return GM_setValue(prefixedKey, value);
    
  }
}

function remove(storageOpt, key) {
  var storage = storageOpt !== undefined ? storageOpt : "Local";
  var prefixedKey = storagePrefix + key;
  switch (storage) {
    case "Local" :
        localStorage.removeItem(prefixedKey);
        return Promise.resolve();
    case "Session" :
        sessionStorage.removeItem(prefixedKey);
        return Promise.resolve();
    case "GM" :
        return GM_deleteValue(prefixedKey);
    
  }
}

function getJson(storageOpt, key) {
  var storage = storageOpt !== undefined ? storageOpt : "Local";
  var __x = get(storage, key);
  return Js_promise.then_((function (value) {
                if (value === undefined) {
                  return Promise.resolve(undefined);
                }
                try {
                  return Promise.resolve(JSON.parse(value));
                }
                catch (exn){
                  return Promise.resolve(undefined);
                }
              }), __x);
}

function setJson(storageOpt, key, value) {
  var storage = storageOpt !== undefined ? storageOpt : "Local";
  return set(storage, key, JSON.stringify(value));
}

var $$Storage = {
  storagePrefix: storagePrefix,
  prefixKey: prefixKey,
  get: get,
  set: set,
  remove: remove,
  getJson: getJson,
  setJson: setJson
};

function methodToString(m) {
  switch (m) {
    case "GET" :
        return "GET";
    case "POST" :
        return "POST";
    case "PUT" :
        return "PUT";
    case "DELETE" :
        return "DELETE";
    case "PATCH" :
        return "PATCH";
    
  }
}

function $$fetch(methodOpt, headers, url) {
  var method = methodOpt !== undefined ? methodOpt : "GET";
  return new Promise((function (resolve, reject) {
                GM_xmlHttpRequest({
                      method: methodToString(method),
                      url: url,
                      headers: headers,
                      onload: (function (resp) {
                          resolve({
                                status: resp.status,
                                statusText: resp.statusText,
                                responseText: resp.responseText,
                                responseHeaders: resp.responseHeaders
                              });
                        }),
                      onerror: (function (err) {
                          reject(Js_exn.raiseError((err.statusText || "Network error")));
                        })
                    });
              }));
}

function fetchJson(methodOpt, headers, url) {
  var method = methodOpt !== undefined ? methodOpt : "GET";
  var __x = $$fetch(method, headers, url);
  return Js_promise.then_((function (resp) {
                return Promise.resolve(JSON.parse(resp.responseText));
              }), __x);
}

var HTTP = {
  methodToString: methodToString,
  $$fetch: $$fetch,
  fetchJson: fetchJson
};

var baseCSS = "\n    .grim-panel {\n      position: fixed;\n      z-index: 99999;\n      background: #ffffff;\n      border: 1px solid #dfe6e9;\n      border-radius: 8px;\n      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      font-size: 14px;\n      color: #2d3436;\n    }\n    .grim-panel-header {\n      padding: 12px 16px;\n      border-bottom: 1px solid #dfe6e9;\n      font-weight: 600;\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n    }\n    .grim-panel-body {\n      padding: 16px;\n      max-height: 400px;\n      overflow-y: auto;\n    }\n    .grim-panel-close {\n      cursor: pointer;\n      opacity: 0.6;\n      transition: opacity 0.2s;\n    }\n    .grim-panel-close:hover {\n      opacity: 1;\n    }\n    .grim-badge {\n      display: inline-flex;\n      align-items: center;\n      padding: 4px 8px;\n      border-radius: 4px;\n      font-size: 12px;\n      font-weight: 500;\n    }\n    .grim-badge-success { background: #d4edda; color: #155724; }\n    .grim-badge-warning { background: #fff3cd; color: #856404; }\n    .grim-badge-error { background: #f8d7da; color: #721c24; }\n    .grim-badge-info { background: #cce5ff; color: #004085; }\n    .grim-toast {\n      position: fixed;\n      bottom: 20px;\n      right: 20px;\n      padding: 12px 24px;\n      background: #2d3436;\n      color: #ffffff;\n      border-radius: 8px;\n      z-index: 100000;\n      animation: grim-toast-in 0.3s ease;\n    }\n    @keyframes grim-toast-in {\n      from { transform: translateY(100%); opacity: 0; }\n      to { transform: translateY(0); opacity: 1; }\n    }\n    .grim-toast-out {\n      animation: grim-toast-out 0.3s ease forwards;\n    }\n    @keyframes grim-toast-out {\n      from { transform: translateY(0); opacity: 1; }\n      to { transform: translateY(100%); opacity: 0; }\n    }\n  ";

var initialized = {
  contents: false
};

function init() {
  if (!initialized.contents) {
    GM_addStyle(baseCSS);
    initialized.contents = true;
    return debug("UI initialized");
  }
  
}

function createPanel(title, positionOpt, draggableOpt) {
  var position = positionOpt !== undefined ? positionOpt : [
      20,
      20
    ];
  init();
  var panel = create("div", "grim-panel", undefined);
  panel["style.cssText"] = "top: " + position[0].toString() + "px; right: " + position[1].toString() + "px;";
  panel.innerHTML = "\n      <div class=\"grim-panel-header\">\n        <span>" + title + "</span>\n        <span class=\"grim-panel-close\">âœ•</span>\n      </div>\n      <div class=\"grim-panel-body\"></div>\n    ";
  var btn = Caml_option.nullable_to_opt(document.querySelector(".grim-panel-close"));
  if (btn !== undefined) {
    Caml_option.valFromOption(btn).addEventListener("click", (function (param) {
            panel.remove();
          }));
  }
  document.body.appendChild(panel);
  return panel;
}

function toast(message, durationOpt) {
  var duration = durationOpt !== undefined ? durationOpt : 3000;
  init();
  var toastEl = create("div", "grim-toast", undefined);
  toastEl.textContent = message;
  document.body.appendChild(toastEl);
  setTimeout((function () {
          toastEl["classList.add"]("grim-toast-out");
          setTimeout((function () {
                  toastEl.remove();
                }), 300);
        }), duration);
}

function createBadge(text, variantOpt) {
  var variant = variantOpt !== undefined ? variantOpt : "info";
  var badge = create("span", "grim-badge grim-badge-" + variant, undefined);
  badge.textContent = text;
  return badge;
}

var UI = {
  baseCSS: baseCSS,
  initialized: initialized,
  init: init,
  createPanel: createPanel,
  toast: toast,
  createBadge: createBadge
};

var scripts = {};

function register(name, info) {
  scripts[name] = info;
  debug("Registered script: " + name);
}

function get$1(name) {
  return Js_dict.get(scripts, name);
}

function list() {
  return Object.keys(scripts);
}

var Registry = {
  scripts: scripts,
  register: register,
  get: get$1,
  list: list
};

function isGitLab() {
  return location.host.includes("gitlab");
}

function isGitHub() {
  return location.host.includes("github");
}

function isCodeberg() {
  return location.host.includes("codeberg");
}

function matchesPattern(pattern) {
  var regex = pattern.replace(/\*/g, ".*").replace(/\?/g, ".");
  return new RegExp(regex).test(location.href);
}

var $$URL = {
  isGitLab: isGitLab,
  isGitHub: isGitHub,
  isCodeberg: isCodeberg,
  matchesPattern: matchesPattern
};

function init$1(debugOpt) {
  var debug = debugOpt !== undefined ? debugOpt : false;
  setDebug(debug);
  console.log(prefix, "GrimCore initialized v1.0.0");
}

export {
  GM ,
  Config ,
  Log ,
  DOM ,
  $$Storage ,
  HTTP ,
  UI ,
  Registry ,
  $$URL ,
  init$1 as init,
}
/* No side effect */
