// SPDX-License-Identifier: MIT AND Palimpsest-0.8
/**
 * Golden Registry Auditor
 * Runs diagnostic checks and determines repository quality level
 */

import type { AuditResult } from './types';
import { analyzeStructure, getStructureRecommendations } from './bootstrap';
import { analyzeCommunityStandards, getCommunityRecommendations, checkRSRCompliance } from './community';

/**
 * Performs comprehensive repository audit
 */
export function auditRepository(
  existingPaths: ReadonlyArray<string>,
  existingFiles: ReadonlyArray<string>
): AuditResult {
  const structure = analyzeStructure(existingPaths);
  const community = analyzeCommunityStandards(existingFiles);

  const overallScore = calculateOverallScore(structure.score, community.score);
  const level = determineQualityLevel(overallScore, structure, community);

  const recommendations = [
    ...getStructureRecommendations(structure),
    ...getCommunityRecommendations(community),
    ...getAdditionalRecommendations(level),
  ];

  return {
    structure,
    community,
    overallScore,
    level,
    recommendations,
  };
}

/**
 * Calculates weighted overall score
 */
function calculateOverallScore(structureScore: number, communityScore: number): number {
  // Community standards are weighted more heavily (60/40 split)
  const weighted = (communityScore * 0.6) + (structureScore * 0.4);
  return Math.round(weighted);
}

/**
 * Determines repository quality level
 */
function determineQualityLevel(
  score: number,
  structure: ReturnType<typeof analyzeStructure>,
  community: ReturnType<typeof analyzeCommunityStandards>
): 'raw' | 'bronze' | 'silver' | 'gold' | 'rhodium' {
  // RSR Bronze requires specific files
  const meetsRSR = checkRSRCompliance(community);

  if (score >= 95 && meetsRSR) {
    return 'rhodium';
  } else if (score >= 85 && meetsRSR) {
    return 'gold';
  } else if (score >= 75 && meetsRSR) {
    return 'silver';
  } else if (score >= 60 && meetsRSR) {
    return 'bronze';
  } else {
    return 'raw';
  }
}

/**
 * Provides level-specific recommendations
 */
function getAdditionalRecommendations(
  level: 'raw' | 'bronze' | 'silver' | 'gold' | 'rhodium'
): ReadonlyArray<string> {
  switch (level) {
    case 'rhodium':
      return [
        'ðŸ† Rhodium Level: Exceptional repository!',
        'ðŸ’Ž Consider submitting to Rhodium Register',
        'âœ¨ Serve as example for other repositories',
      ];

    case 'gold':
      return [
        'ðŸ¥‡ Gold Level: Excellent repository!',
        'ðŸ“ˆ Next step: Improve documentation depth',
        'ðŸŽ¯ Consider adding examples and guides',
      ];

    case 'silver':
      return [
        'ðŸ¥ˆ Silver Level: Strong repository!',
        'ðŸ“š Next step: Enhance test coverage',
        'ðŸ” Consider adding more automation',
      ];

    case 'bronze':
      return [
        'ðŸ¥‰ Bronze Level: Good foundation!',
        'ðŸ“‹ Next step: Complete recommended files',
        'ðŸ› ï¸  Consider adding build automation',
      ];

    case 'raw':
      return [
        'ðŸ“¦ Raw Project: Basic setup needed',
        'ðŸš€ Start with: LICENSE, README, CONTRIBUTING',
        'ðŸ’¡ Use GrimRepo tools to scaffold structure',
      ];
  }
}

/**
 * Generates audit report as markdown
 */
export function generateAuditReport(audit: AuditResult): string {
  const lines: string[] = [];

  lines.push('# GrimRepo Audit Report\n');

  lines.push(`**Overall Score**: ${audit.overallScore}/100`);
  lines.push(`**Quality Level**: ${audit.level.toUpperCase()}\n`);

  lines.push('## Structure Analysis\n');
  lines.push(`**Score**: ${audit.structure.score}/100`);
  lines.push(`**Present Directories**: ${audit.structure.presentDirs.length}`);
  lines.push(`**Missing Directories**: ${audit.structure.missingDirs.length}\n`);

  if (audit.structure.missingDirs.length > 0) {
    lines.push('### Missing Directories\n');
    for (const dir of audit.structure.missingDirs) {
      lines.push(`- **${dir.path}**: ${dir.purpose} (${dir.priority})`);
    }
    lines.push('');
  }

  lines.push('## Community Standards Analysis\n');
  lines.push(`**Score**: ${audit.community.score}/100`);
  lines.push(`**Present Files**: ${audit.community.presentFiles.length}`);
  lines.push(`**Missing Files**: ${audit.community.missingFiles.length}\n`);

  if (audit.community.missingFiles.length > 0) {
    lines.push('### Missing Files\n');
    for (const file of audit.community.missingFiles) {
      lines.push(`- **${file.path}**: ${file.purpose} (${file.priority})`);
    }
    lines.push('');
  }

  lines.push('## Recommendations\n');
  for (const rec of audit.recommendations) {
    lines.push(`- ${rec}`);
  }

  lines.push('\n---\n');
  lines.push('Generated by GrimRepo Scripts');

  return lines.join('\n');
}

/**
 * Generates JSON report for programmatic consumption
 */
export function generateJSONReport(audit: AuditResult): string {
  return JSON.stringify(audit, null, 2);
}
